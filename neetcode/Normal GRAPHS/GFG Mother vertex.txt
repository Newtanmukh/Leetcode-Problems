//Topological sorting. the first node has to be the required node otherwise it is not. 


vector<int>ans;
    vector<int>temp;
    
    void topological_sort(int node,vector<bool>&visited,vector<int>adj[])
    {
        visited[node]=true;
       
        
        for(auto neighbour:adj[node])
        {
            if(visited[neighbour]==false)
            {
                topological_sort(neighbour,visited,adj);
            }
        }
        ans.push_back(node);
    }
    
    void dfs(int node,vector<bool>&visited,vector<int>adj[])
    {
        visited[node]=true;
        
        temp.push_back(node);
        
        for(int neighbour:adj[node])
        {
            if(visited[neighbour]==false)
            {
                dfs(neighbour,visited,adj);
            }
        }
    }
    
    int findMotherVertex(int V, vector<int>adj[])
    {
     vector<bool>visited(V,false);
     
    for(int i=0;i<V;i++)
    {
        if(visited[i]==false)
        {
            topological_sort(i,visited,adj);
        }
    }
    
    int size=ans.size();
    
    for(int i=0;i<V;i++)
    {
        visited[i]=false;
    }
    int top=ans[ans.size()-1];
    
    dfs(top,visited,adj);
    
    if(temp.size()==size)
    return top;
    
    return -1;
     
    }
